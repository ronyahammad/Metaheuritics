
# DIMACS CNF Format and Satisfiability Problem

The **DIMACS CNF format** is a textual representation of a formula in **conjunctive normal form (CNF)**.  

A formula in CNF is expressed as a conjunction (**logical AND**, ∧) of a set of clauses.  
Each clause is a disjunction (**logical OR**, ∨) of a set of literals.  
A literal is either a variable or the negation of a variable.  

In DIMACS CNF:  
- Positive integers represent variables.  
- Negative integers represent the corresponding negated variables.  

### Example Formula

If we let \( x_i \) represent variables that can take the values `true` or `false`, a sample formula in CNF could be:  

\[
(x_1 \lor x_3 \lor \neg x_4) \land (x_4) \land (x_2 \lor \neg x_3)
\]

Where:  
- \( \lor \) represents the **OR** Boolean connective.  
- \( \land \) represents the **AND** Boolean connective.  
- \( \neg \) represents **negation**.  

### Satisfiability Problem

Given a set of clauses \( C_1, C_2, \dots, C_m \) on variables \( x_1, x_2, \dots, x_n \), the **satisfiability problem** asks whether there exists an assignment of values to the variables such that the formula:

\[
C_1 \land C_2 \land \dots \land C_m
\]

evaluates to `true`.  
For this to happen, **every clause \( C_j \) must evaluate to true**.  

### Maximum Satisfiability Problem

The **maximum satisfiability problem** (MaxSAT) seeks to find an assignment of values to the variables such that the **maximum number of clauses \( C_j \)** evaluate to `true`.

---

## Implementation Details

I am using a **brute-force approach** to solve the task.  
The files used in this implementation are:  
- `uf20-01.cnf`  
- `uf20-091.cnf`  
- `uf100-0430.cnf`  

Before proceeding, I created a custom file named `hoos.cnf` with the following content:

```
c This formula is generated by mcnf
c
c horn? no
c forced? no
c mixed sat? no
c clause length = 3
c
p cnf 5 6
-1 2 0
-2 1 0
-1 -2 -3 0
1 2 0
-4 3 0
-5 3 0
%
0
```
